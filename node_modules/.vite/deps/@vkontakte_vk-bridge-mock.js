import "./chunk-EQCVQC35.js";

// node_modules/@vkontakte/vk-bridge-mock/dist/index.es.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
}
function createCounter() {
  return {
    current: 0,
    next: function() {
      return ++this.current;
    }
  };
}
function createRequestResolver() {
  var counter = createCounter();
  var promiseControllers = {};
  return {
    /**
     * Adds new controller with resolve/reject methods.
     *
     * @param controller Object with `resolve` and `reject` functions
     * @param customId Custom `request_id`
     * @returns New request id of the added controller.
     */
    add: function(controller, customId) {
      var id = customId != null ? customId : counter.next();
      promiseControllers[id] = controller;
      return id;
    },
    /**
     * Resolves/rejects an added promise by request id and the `isSuccess`
     * predicate.
     *
     * @param requestId Request ID.
     * @param data Data to pass to the resolve- or reject-function.
     * @param isSuccess Predicate to select the desired function.
     */
    resolve: function(requestId, data, isSuccess) {
      var requestPromise = promiseControllers[requestId];
      if (requestPromise) {
        if (isSuccess(data)) {
          requestPromise.resolve(data);
        } else {
          requestPromise.reject(data);
        }
        promiseControllers[requestId] = null;
      }
    }
  };
}
function promisifySend(sendEvent, subscribe2) {
  var requestResolver = createRequestResolver();
  subscribe2(function(event) {
    if (!event.detail || !event.detail.data || typeof event.detail.data !== "object") {
      return;
    }
    if ("request_id" in event.detail.data) {
      var _a = event.detail.data, requestId = _a.request_id, data = __rest(_a, ["request_id"]);
      if (requestId) {
        requestResolver.resolve(requestId, data, function(data2) {
          return !("error_type" in data2);
        });
      }
    }
  });
  return function promisifiedSend(method, props) {
    if (props === void 0) {
      props = {};
    }
    return new Promise(function(resolve, reject) {
      var requestId = requestResolver.add({
        resolve,
        reject
      }, props.request_id);
      sendEvent(method, __assign(__assign({}, props), {
        request_id: requestId
      }));
    });
  };
}
var IS_CLIENT_SIDE = typeof window !== "undefined";
var IS_ANDROID_WEBVIEW = Boolean(IS_CLIENT_SIDE && window.AndroidBridge);
var IS_IOS_WEBVIEW = Boolean(IS_CLIENT_SIDE && window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers.VKWebAppClose);
var IS_WEB = IS_CLIENT_SIDE && !IS_ANDROID_WEBVIEW && !IS_IOS_WEBVIEW;
var IS_MVK = IS_WEB && /(^\?|&)vk_platform=mobile_web(&|$)/.test(location.search);
var IS_DESKTOP_VK = IS_WEB && !IS_MVK;
var EVENT_TYPE = IS_WEB ? "message" : "VKWebAppEvent";
var DESKTOP_METHODS = __spreadArrays(["VKWebAppInit", "VKWebAppGetCommunityAuthToken", "VKWebAppAddToCommunity", "VKWebAppAddToHomeScreenInfo", "VKWebAppClose", "VKWebAppCopyText", "VKWebAppGetUserInfo", "VKWebAppSetLocation", "VKWebAppSendToClient", "VKWebAppGetClientVersion", "VKWebAppGetPhoneNumber", "VKWebAppGetEmail", "VKWebAppGetGroupInfo", "VKWebAppGetGeodata", "VKWebAppGetCommunityToken", "VKWebAppSetTitle", "VKWebAppGetAuthToken", "VKWebAppCallAPIMethod", "VKWebAppJoinGroup", "VKWebAppLeaveGroup", "VKWebAppAllowMessagesFromGroup", "VKWebAppDenyNotifications", "VKWebAppAllowNotifications", "VKWebAppOpenPayForm", "VKWebAppOpenApp", "VKWebAppShare", "VKWebAppShowWallPostBox", "VKWebAppScroll", "VKWebAppShowOrderBox", "VKWebAppShowLeaderBoardBox", "VKWebAppShowInviteBox", "VKWebAppShowRequestBox", "VKWebAppAddToFavorites", "VKWebAppShowCommunityWidgetPreviewBox", "VKWebAppShowStoryBox", "VKWebAppSendToClient", "VKWebAppStorageGet", "VKWebAppStorageGetKeys", "VKWebAppStorageSet", "VKWebAppFlashGetInfo", "VKWebAppSubscribeStoryApp", "VKWebAppOpenWallPost"], IS_DESKTOP_VK ? ["VKWebAppResizeWindow", "VKWebAppAddToMenu", "VKWebAppShowSubscriptionBox", "VKWebAppShowInstallPushBox", "VKWebAppGetFriends"] : []);
var androidBridge = IS_CLIENT_SIDE ? window.AndroidBridge : void 0;
var iosBridge = IS_IOS_WEBVIEW ? window.webkit.messageHandlers : void 0;
function createVKBridge(version2) {
  var webFrameId = void 0;
  var subscribers = [];
  function send2(method, props) {
    if (androidBridge && androidBridge[method]) {
      androidBridge[method](JSON.stringify(props));
    } else if (iosBridge && iosBridge[method] && typeof iosBridge[method].postMessage === "function") {
      iosBridge[method].postMessage(props);
    } else if (IS_WEB) {
      parent.postMessage({
        handler: method,
        params: props,
        type: "vk-connect",
        webFrameId,
        connectVersion: version2
      }, "*");
    }
  }
  function subscribe2(listener) {
    subscribers.push(listener);
  }
  function unsubscribe2(listener) {
    var index = subscribers.indexOf(listener);
    if (index > -1) {
      subscribers.splice(index, 1);
    }
  }
  function supports(method) {
    if (IS_ANDROID_WEBVIEW) {
      return !!(androidBridge && typeof androidBridge[method] === "function");
    } else if (IS_IOS_WEBVIEW) {
      return !!(iosBridge && iosBridge[method] && typeof iosBridge[method].postMessage === "function");
    } else if (IS_WEB) {
      return DESKTOP_METHODS.indexOf(method) > -1;
    }
    return false;
  }
  function isWebView() {
    return IS_IOS_WEBVIEW || IS_ANDROID_WEBVIEW;
  }
  function isIframe() {
    return IS_WEB && window.parent !== window;
  }
  function isEmbedded() {
    return isWebView() || isIframe();
  }
  function isStandalone() {
    return !isEmbedded();
  }
  if (typeof window !== "undefined" && "addEventListener" in window) {
    window.addEventListener(EVENT_TYPE, function(event) {
      if (IS_IOS_WEBVIEW || IS_ANDROID_WEBVIEW) {
        return __spreadArrays(subscribers).map(function(fn) {
          return fn.call(null, event);
        });
      } else if (IS_WEB && event && event.data) {
        var _a = event.data, type_1 = _a.type, data_1 = _a.data, frameId = _a.frameId;
        if (type_1 && type_1 === "VKWebAppSettings") {
          webFrameId = frameId;
        } else {
          __spreadArrays(subscribers).map(function(fn) {
            return fn({
              detail: {
                type: type_1,
                data: data_1
              }
            });
          });
        }
      }
    });
  }
  var sendPromise = promisifySend(send2, subscribe2);
  return {
    send: sendPromise,
    sendPromise,
    subscribe: subscribe2,
    unsubscribe: unsubscribe2,
    supports,
    isWebView,
    isIframe,
    isEmbedded,
    isStandalone
  };
}
function createCustomEventPolyfill() {
  function CustomEvent(typeArg, eventInitDict) {
    var params = eventInitDict || {
      bubbles: false,
      cancelable: false,
      detail: void 0
    };
    var evt = document.createEvent("CustomEvent");
    evt.initCustomEvent(typeArg, !!params.bubbles, !!params.cancelable, params.detail);
    return evt;
  }
  CustomEvent.prototype = Event.prototype;
  return CustomEvent;
}
var version = "2.4.1";
if (typeof window !== "undefined" && !window.CustomEvent) {
  window.CustomEvent = createCustomEventPolyfill();
}
var bridge = createVKBridge(version);
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var state = {
  listeners: [],
  currentRequestId: 0,
  appStorage: {
    keys: [
      { key: "somekey0", value: "somevalue0" },
      { key: "somekey1", value: "somevalue1" }
    ]
  },
  getNextRequestId: function() {
    this.currentRequestId++;
    return this.currentRequestId;
  },
  getAppStorage: function(_a) {
    var keys = _a.keys;
    return { keys: this.appStorage.keys.filter(function(it) {
      return keys.includes(it.key);
    }) };
  },
  getAppStorageKeys: function() {
    return { keys: this.appStorage.keys.map(function(it) {
      return it.key;
    }) };
  },
  setAppStorageItem: function(_a) {
    var key = _a.key, value = _a.value;
    this.appStorage = { keys: state.appStorage.keys.concat({ key, value }) };
    return { result: true };
  }
};
var mockAccessToken = "yours000access111token222yours000access111token222yours000access111token2220123456789";
var mockDataMap = {
  VKWebAppInit: function() {
    return { result: true };
  },
  VKWebAppAddToCommunity: function() {
    return { group_id: 123456789 };
  },
  VKWebAppAllowMessagesFromGroup: function() {
    return { result: true };
  },
  VKWebAppAllowNotifications: function() {
    return { result: true };
  },
  VKWebAppCallAPIMethod: function() {
    return {
      response: [
        {
          id: 210700286,
          first_name: "Lindsey",
          last_name: "Stirling",
          is_closed: false,
          can_access_closed: true,
          city: { id: 5331, title: "Los Angeles" },
          photo_50: "https://vk.com/images/camera_50.png",
          verified: 1
        }
      ]
    };
  },
  VKWebAppGetAuthToken: function() {
    return { access_token: mockAccessToken, scope: "friends,photos,video,wall" };
  },
  VKWebAppClose: function() {
    return { payload: {} };
  },
  VKWebAppOpenApp: function() {
    return { result: true };
  },
  VKWebAppDenyNotifications: function() {
    return { result: true };
  },
  VKWebAppFlashGetInfo: function() {
    return { is_available: true, level: 1.6 };
  },
  VKWebAppFlashSetLevel: function() {
    return { result: true };
  },
  VKWebAppGetClientVersion: function() {
    return { platform: "android", version: "5.3.2" };
  },
  VKWebAppGetEmail: function() {
    return { email: "test@gmail.com", sign: "Y1C99xnbEaR8Wred" };
  },
  VKWebAppGetFriends: function() {
    return {
      users: [
        { id: 2884043, first_name: "Albert", last_name: "Usmanov", sex: 2, photo_200: "https://vk.com/images/camera_200.png" },
        { id: 1894768, first_name: "Aleksandra", last_name: "Sokolovskaya", sex: 1, photo_200: "https://vk.com/images/camera_200.png" }
      ]
    };
  },
  VKWebAppGetGeodata: function() {
    return { available: 1, lat: 59.938, long: 30.312, accuracy: 65 };
  },
  VKWebAppGetPersonalCard: function() {
    return {
      phone: "+79001112233",
      email: "ivan@gmail.com",
      address: {
        country: { id: 1, name: "Россия" },
        city: { id: 2, name: "Санкт-Петербург" },
        specified_address: "Невский пр., д. 28",
        postal_code: "191186"
      }
    };
  },
  VKWebAppGetPhoneNumber: function() {
    return { phone_number: "79111234567", sign: "Y1C99xnbEaR8Wred", is_verified: true };
  },
  VKWebAppGetUserInfo: function() {
    return {
      id: 2314852,
      first_name: "Ирина",
      last_name: "Денежкина",
      sex: 1,
      city: { id: 2, title: "Санкт-Петербург" },
      country: { id: 1, title: "Россия" },
      bdate: "10.4.1990",
      photo_100: "https://vk.com/images/camera_100.png",
      photo_200: "https://vk.com/images/camera_200.png",
      timezone: 3
    };
  },
  VKWebAppJoinGroup: function() {
    return { result: true };
  },
  VKWebAppOpenCodeReader: function() {
    return { code_data: "Some text" };
  },
  VKWebAppOpenQR: function() {
    return { code_data: "Some text" };
  },
  VKWebAppOpenContacts: function() {
    return { phone: "79217770099", first_name: "Сестра", last_name: "" };
  },
  VKWebAppOpenPayForm: function() {
    return {
      status: true,
      transaction_id: "150349AC-BDC6-11E9-83B6-5D798FB6FAB1",
      amount: "1.01",
      extra: null
    };
  },
  VKWebAppResizeWindow: function() {
    return { width: 800, height: 1e3 };
  },
  VKWebAppScroll: function() {
    return { top: 1, height: 2040 };
  },
  VKWebAppSetLocation: function() {
    return { result: true };
  },
  VKWebAppSetViewSettings: function() {
    return { result: true };
  },
  VKWebAppShare: function() {
    return { type: "link" };
  },
  VKWebAppShowCommunityWidgetPreviewBox: function() {
    return { result: true };
  },
  VKWebAppShowImages: function() {
    return { result: true };
  },
  VKWebAppShowInviteBox: function() {
    return { success: true };
  },
  VKWebAppShowLeaderBoardBox: function() {
    return { success: true };
  },
  VKWebAppShowMessageBox: function() {
    return { result: true };
  },
  VKWebAppShowOrderBox: function() {
    return { status: "cancel" };
  },
  VKWebAppShowRequestBox: function() {
    return { success: true, requestKey: "123242" };
  },
  VKWebAppShowWallPostBox: function() {
    return { post_id: 1 };
  },
  VKWebAppStorageGet: state.getAppStorage.bind(state),
  VKWebAppStorageGetKeys: state.getAppStorageKeys.bind(state),
  VKWebAppStorageSet: state.setAppStorageItem.bind(state),
  VKWebAppTapticImpactOccurred: function() {
    return { result: true };
  },
  VKWebAppTapticNotificationOccurred: function() {
    return { result: true };
  },
  VKWebAppTapticSelectionChanged: function() {
    return { result: true };
  },
  VKWebAppAddToFavorites: function() {
    return { result: true };
  },
  VKWebAppSendPayload: function() {
    return { result: true };
  },
  VKWebAppGetCommunityToken: function() {
    return { access_token: mockAccessToken };
  },
  VKWebAppDisableSwipeBack: function() {
    return { result: true };
  },
  VKWebAppEnableSwipeBack: function() {
    return { result: true };
  },
  // Incoming only methods
  VKWebAppAudioPaused: function() {
    return { type: "file", position: 34, id: "audio_track_01.mp3" };
  },
  VKWebAppAudioStopped: function() {
    return {};
  },
  VKWebAppAudioTrackChanged: function() {
    return { type: "file", id: "audio_track_01.mp3" };
  },
  VKWebAppAudioUnpaused: function() {
    return { type: "file", id: "audio_track_01.mp3" };
  },
  VKWebAppInitAds: function() {
    return { init: "true" };
  },
  VKWebAppLoadAds: function() {
    return { load: "true" };
  },
  VKWebAppUpdateConfig: function() {
    return {
      app: "vkclient",
      app_id: "3087106",
      appearance: "light",
      insets: { top: 0, left: 0, right: 0, bottom: 0 },
      scheme: "client_light",
      start_time: 1565272434911599e-6
    };
  },
  VKWebAppViewHide: function() {
    return {};
  },
  VKWebAppViewRestore: function() {
    return {};
  },
  VKWebAppShowStoryBox: function() {
    return { result: true };
  },
  VKWebAppAccelerometerChanged: function() {
    return { x: "3.0", y: "-1.3", z: "0.0" };
  },
  VKWebAppAccelerometerStart: function() {
    return { result: true };
  },
  VKWebAppAccelerometerStop: function() {
    return { result: true };
  },
  VKWebAppAudioPause: function() {
    return { result: true };
  },
  VKWebAppCopyText: function() {
    return { result: true };
  },
  VKWebAppDeviceMotionChanged: function() {
    return { alpha: "3.0", beta: "-1.3", gamma: "0.0" };
  },
  VKWebAppDeviceMotionStart: function() {
    return { result: true };
  },
  VKWebAppDeviceMotionStop: function() {
    return { result: true };
  },
  VKWebAppGyroscopeChanged: function() {
    return { x: "3.0", y: "-1.3", z: "0.0" };
  },
  VKWebAppGyroscopeStart: function() {
    return { result: true };
  },
  VKWebAppGyroscopeStop: function() {
    return { result: true };
  },
  VKWebAppLocationChanged: function() {
    return { location: "test" };
  },
  VKWebAppSubscribeStoryApp: function() {
    return { access_key: mockAccessToken };
  },
  VKWebAppUpdateInsets: function() {
    return { insets: { right: 0, top: 44, left: 0, bottom: 34 } };
  },
  VKWebAppAddToHomeScreen: function() {
    return { result: true };
  },
  VKWebAppAddToHomeScreenInfo: function() {
    return { is_feature_supported: true, is_added_to_home_screen: true };
  },
  OKWebAppCallAPIMethod: function() {
    return {
      response: [
        {
          id: 584276368330,
          last_name: "Терещенков",
          is_closed: false,
          can_access_closed: true,
          first_name: "Денис"
        }
      ]
    };
  },
  VKWebAppDownloadFile: function() {
    return { result: true };
  },
  VKWebAppLeaveGroup: function() {
    return { result: true };
  },
  VKWebAppAddToMenu: function() {
    return { result: true };
  },
  VKWebAppSendToClient: function() {
    return { result: true };
  },
  VKWebAppOpenWallPost: function() {
    return { result: true };
  },
  VKWebAppSetSwipeSettings: function() {
    return { result: true };
  },
  VKWebAppGetGroupInfo: function() {
    return {
      id: 166562603,
      name: "VK Mini Apps",
      screen_name: "club166562603",
      photo_50: "https://vk.com/images/community_50.png",
      photo_100: "https://vk.com/images/community_100.png",
      photo_200: "https://vk.com/images/community_200.png",
      is_closed: 0,
      members_count: 46978,
      description: "Group Description",
      type: "page",
      is_member: 1
    };
  },
  VKWebAppLibverifyOnConfirmed: function() {
    return { validate_session: "some_string", validate_token: "some_token" };
  },
  VKWebAppLibverifyOnFailed: function() {
    return { code: "INCORRECT_PHONE_NUMBER" };
  },
  VKWebAppRetargetingPixel: function() {
    return { result: true };
  }
};
var receiveOnlyMethods = [
  "VKWebAppAudioPaused",
  "VKWebAppAudioStopped",
  "VKWebAppAudioTrackChanged",
  "VKWebAppAudioUnpaused",
  "VKWebAppInitAds",
  "VKWebAppLoadAds",
  "VKWebAppUpdateConfig",
  "VKWebAppViewHide",
  "VKWebAppViewRestore"
];
var getMockData = function(methodName, props) {
  if (isReceiveMockMethodExists(methodName) && mockDataMap[methodName]) {
    return mockDataMap[methodName](props);
  }
  return null;
};
var isReceiveOnlyMethod = function(method) {
  return receiveOnlyMethods.includes(method);
};
var broadcastData = function(event) {
  state.listeners.forEach(function(listener) {
    listener(event);
  });
};
var prepareResponse = function(method, props) {
  if (!isReceiveMockMethodExists(method)) {
    throw new Error("Missing mock data for " + method + " event");
  }
  var mockData = getMockData(method, props);
  if (mockData == null) {
    throw new Error("Unable to get mock data for " + method + " event");
  }
  if (isReceiveOnlyMethod(method)) {
    return {
      detail: {
        type: method,
        data: mockData
      }
    };
  } else {
    var data = __assign$1(__assign$1({}, getMockData(method, props)), { request_id: state.getNextRequestId() });
    var type = method + "Result";
    return {
      detail: {
        type,
        data
      }
    };
  }
};
var isReceiveMockMethodExists = function(methodName) {
  return methodName in mockDataMap;
};
var send = function(method, props) {
  return __awaiter(void 0, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, new Promise(function(resolve, reject) {
        if (!isReceiveMockMethodExists(method)) {
          return;
        }
        var event = prepareResponse(method, props);
        if (!event) {
          return;
        }
        broadcastData(event);
        resolve(event.detail.data);
      })];
    });
  });
};
var subscribe = function(fn) {
  return void state.listeners.push(fn);
};
var unsubscribe = function(fn) {
  var index = state.listeners.indexOf(fn);
  if (index > -1) {
    state.listeners.splice(index, 1);
  }
};
var callReceiveOnlyMethod = function(methodName) {
  if (receiveOnlyMethods.includes(methodName)) {
    var event_1 = prepareResponse(methodName);
    if (event_1) {
      broadcastData(event_1);
    }
  }
};
var bridgeMock = {
  /**
   * Sends an event to the runtime env and returns the Promise object with
   * response data. In the case of Android/iOS application env is the
   * application itself. In the case of the browser, the parent frame in which
   * the event handlers is located.
   *
   * @param method The method (event) name to send.
   * @param [props] Method properties.
   * @returns The Promise object with response data.
   */
  send,
  /**
   * @alias send
   * @deprecated
   */
  sendPromise: send,
  /**
   * Adds an event listener. It will be called any time a data is received.
   *
   * @param listener A callback to be invoked on every event receive.
   */
  subscribe,
  /**
   * Removes an event listener which has been subscribed for event listening.
   *
   * @param listener A callback to unsubscribe.
   */
  unsubscribe,
  /**
   * Checks if a method is supported on runtime platform.
   *
   * @param method Method (event) name to check.
   * @returns Result of checking.
   */
  supports: function(method) {
    return bridge.supports(method);
  },
  /**
   * Checks whether the runtime is a WebView.
   *
   * @returns Result of checking.
   */
  isWebView: function() {
    return bridge.isWebView();
  },
  /**
   * Checks whether the runtime is an iframe.
   *
   * @returns Result of checking.
   */
  isIframe: function() {
    return bridge.isIframe();
  },
  /**
  * Checks whether the runtime is embedded.
  *
  * @returns Result of checking.
  */
  isEmbedded: function() {
    return bridge.isEmbedded();
  },
  /**
   * Checks whether the runtime is standalone.
   *
   * @returns Result of checking.
   */
  isStandalone: function() {
    return bridge.isStandalone();
  }
};
var index_es_default = bridgeMock;
export {
  callReceiveOnlyMethod,
  index_es_default as default
};
/*! Bundled license information:

@vkontakte/vk-bridge-mock/dist/index.es.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** *)
*/
//# sourceMappingURL=@vkontakte_vk-bridge-mock.js.map
